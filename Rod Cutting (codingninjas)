Rod Cutting(codingninjas)

//Problem Link ------->  https://www.codingninjas.com/codestudio/problems/rod-cutting-problem_800284

//Problem Statement :

We are given a rod of size ‘N’. It can be cut into pieces. Each length of a piece has a particular price given by the price array. 
Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces.


Sample Input 1:
2 Testcases

5
2 5 7 8 10

8
3 5 8 9 10 17 17 20

Sample Output 1:

12
24


Code as Follows -----> 1.recursion ---> 2. Memoisation --> 3. Tabulation. ---> 4. Space Optimisation

1.recursion Method(Gives TLE). --> TC : greater o(2^n) ; SC :o(N)

public class Solution {
	public static int cutRod(int price[], int n) {
		

		return recur(n, price, n);
		
	}
	//Recursion method
	public static int recur(int idx, int price[], int n){
		
		if(idx == 0){
            return n * price[0];
		}

		int nottake = 0 + recur(idx-1, price, n);
		int take = Integer.MIN_VALUE;
		if(idx + 1 <= n){
			take = price[idx] + recur(idx, price, n);
		}

		return Math.max(take, nottake);
	}
  
}

//2.Memoisation  --> TC :  o(n * n) ; SC :o(n * n) + o(N)

import java.util.Arrays;
import java.util.*;

public class Solution {
	public static int cutRod(int price[], int n) {
		int len = price.length;
		int dp[][] = new int[len][n+1];  //n is length

		// for(int i = 0; i < len; i++){
		// 	for(int j = 0 ; j < n+1; j++){
		// 		dp[i][j] = -1;
		// 	}
		// }

		for(int row[] : dp){
			Arrays.fill(row, -1);
		}


		return memo(len -1, price, n, dp);
		
	}
	//Memoisation method
	public static int memo(int idx, int price[], int target, int dp[][]){
		//Recursion method
		if(idx == 0){
            return target * price[idx];
		}

        if(dp[idx][target]!= -1) return dp[idx][target];

		int nottake = memo(idx-1, price, target, dp);
		int take = Integer.MIN_VALUE;
		int rodlength = idx  +1;
		if(rodlength <= target){
			take = price[idx] + memo(idx, price, target -  rodlength, dp);
		}

		return dp[idx][target] = Math.max(take, nottake);
	}
}


//3.Tabulation  --> TC :  o(n * n) ; SC :o(n * n)

import java.util.Arrays;

import java.util.*;

public class Solution {
	public static int cutRod(int price[], int n) {
		//Tabulation Method
		int dp[][] = new int[n][n+1];  //n is length

		for(int row[] : dp){
			Arrays.fill(row, -1);
		}

		//Base case 
		for(int i = 0; i <= n; i++){
			dp[0][i] = i * price[0];
		}

		for(int idx = 1; idx < n ; idx++){
			for(int len = 0; len <= n; len++){

				int nottake = 0+ dp[idx-1][len];

		        int take = Integer.MIN_VALUE;
		        int rodlength = idx  +1;

		        if(rodlength <= len){
			        take = price[idx] + dp[idx] [len -  rodlength];
		        }

				dp[idx][len] = Math.max(nottake, take);

			}
		}
		return dp[n -1][n];	
	}
	
}

//4. Space Optimisation  --> TC :  o(n * n) ; SC :o(n)








